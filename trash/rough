import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import folium
import geopandas as gpd
from shapely.geometry import Point
import networkx as nx
from geopy.distance import geodesic
from tqdm import tqdm
from shapely.geometry import LineString
import heapq
import ipywidgets as widgets
from IPython.display import display, clear_output
from IPython.core.display import HTML
datapath = "../new_data/"
df = pd.read_csv(datapath+"Supercharge Locations.csv")
df_CA = df[df["State"]=="CA"]
df_CA = df_CA.drop(columns=["Unnamed: 11","Country","Open Date", "Elev(m)","State"])
df_CA.at[df_CA[df_CA["Zip"].isnull()].index.values[0],"Zip"] = '91007'
df_CA['Latitude'] = None
df_CA['Longitude'] = None

df_CA[['Latitude', 'Longitude']] = df_CA['GPS'].str.split(', ', expand=True)

# Convert Latitude and Longitude to float if needed
df_CA['Latitude'] = df_CA['Latitude'].astype(float)
df_CA['Longitude'] = df_CA['Longitude'].astype(float)
min_lon = -180
max_lon = 180
min_lat = -90
max_lat = 90
df_road_edge = pd.read_csv(datapath+"cal_road_net_edge.csv")
df_road_node = pd.read_csv(datapath+"cal_road_network_node.csv")
# Since the original dataset had Latitude and Longitude reversed we will swap them
df_road_node['Latitude'], df_road_node['Longitude'] = df_road_node['Longitude'], df_road_node['Latitude']
def limit_coordinates(df, min_lat, max_lat, min_long, max_long):
    # Limit latitude
    df = df[(df['Latitude'] >= min_lat) & (df['Latitude'] <= max_lat)]

    # Limit longitude
    df = df[(df['Longitude'] >= min_long) & (df['Longitude'] <= max_long)]
    return df

df_charger = limit_coordinates(df_CA, min_lat, max_lat, min_lon, max_lon).reset_index()
df_nodes = limit_coordinates(df_road_node, min_lat, max_lat, min_lon, max_lon).reset_index()

df_edges = df_road_edge[df_road_edge["Node1"].isin(df_nodes.Node.to_list()) &
                        df_road_edge["Node2"].isin(df_nodes.Node.to_list())].drop(columns=["Sl"]).reset_index()
df_charger = df_charger.drop(columns="index")
df_nodes = df_nodes.drop(columns="index")
df_edges = df_edges.drop(columns="index")
reduced_map = folium.Map(location=[35, -119], zoom_start=6)
for index, row in df_charger.iterrows():
    zip_code = row['Zip']
    stalls = row['Stalls']
    coordinates = row['GPS'].split(', ')
    kw = row['kW']
    lat, lon = float(coordinates[0]), float(coordinates[1])
    if kw == 250:
        marker_color = 'red'
    elif kw == 150:
        marker_color = 'blue'
    elif kw in [120, 122, 125, 120]:
        marker_color = 'gray'
    elif kw == 72:
        marker_color = 'beige'
    else:
        marker_color = 'green'
    folium.Marker([lat, lon],
                  popup=f"Zip: {zip_code},\nStalls: {stalls},\n{np.floor(kw).astype(int)} kW\n({lat},{lon})",
                  icon=folium.Icon(color=marker_color, icon='bolt', prefix='fa')).add_to(reduced_map)
    
reduced_map
G = nx.Graph()
for index, row in df_nodes.iterrows():
    G.add_node(row['Node'],
               pos=(row['Longitude'], row['Latitude']))
    
for index, row in df_edges.iterrows():
    G.add_edge(row['Node1'], row['Node2'],
               weight = row['Distance'])

charger_points = gpd.GeoDataFrame(df_charger,
                                  geometry=gpd.points_from_xy(df_charger['Longitude'], df_charger['Latitude']))

node_to_charger = []

for node in tqdm(G.nodes, desc="Processing nodes"):
    node_coords = df_nodes.loc[df_nodes['Node'] == node,
                               ['Latitude', 'Longitude']].values.flatten()
    
    nearest_charger_distance = float('inf')
    nearest_charger_coords = None

    for idx, charger in charger_points.iterrows():
        charger_coords = (charger['Latitude'], charger['Longitude'])
        distance = geodesic(node_coords, charger_coords).kilometers

        if distance < nearest_charger_distance:
            nearest_charger_distance = distance
            nearest_charger_coords = charger_coords

    node_to_charger.append({
        'Node': node,
        'Nearest_charger': nearest_charger_coords,
        'Distance': nearest_charger_distance
    })

node_to_charger_df = pd.DataFrame(node_to_charger)
charger_to_nearest_node = {}
for idx, charger in charger_points.iterrows():
    charger_coords = (charger['Latitude'], charger['Longitude'])
    nearest_node = None
    min_distance = float('inf')

    for record in node_to_charger:
        if record['Nearest_charger'] == charger_coords:
            if record['Distance'] < min_distance:
                min_distance = record['Distance']
                nearest_node = record['Node']

    if nearest_node is None:
        print(f"No nearest node found for charger at {charger_coords}")
        
    charger_to_nearest_node[tuple(charger_coords)] = nearest_node

charger_to_nearest_node = pd.DataFrame(list(charger_to_nearest_node.items()), columns=['Charger', 'Nearest_Node'])
charger_to_nearest_node.head()
gdf_nodes = gpd.GeoDataFrame(
    df_nodes,
    geometry=gpd.points_from_xy(df_nodes['Longitude'], df_nodes['Latitude'])
)

edge_list = []
for _, edge in df_edges.iterrows():
    node1_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node1']].geometry.values[0]
    node2_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node2']].geometry.values[0]
    edge_list.append(LineString([node1_coords, node2_coords]))

gdf_edges = gpd.GeoDataFrame(geometry=edge_list)

fig, ax = plt.subplots(figsize=(10,10))
gdf_edges.plot(ax=ax,
               linewidth=1,
               color='gray')

gdf_nodes.plot(ax=ax,
               color='blue',
               marker='o',
               label='Nodes',
               markersize=5)

charger_points.plot(ax=ax,
                    color='red',
                    marker='^',
                    label='Charger',
                    markersize=10)

ax.grid(True)
ax.legend()
ax.set_title("Nodes and Charger Network")

plt.show()
df_charger = pd.concat([charger_points, charger_to_nearest_node], axis=1).drop(columns=["Charger"]).dropna()
df_charger["Nearest_Node"] = np.floor(df_charger["Nearest_Node"]).astype(int)
df_charger.head()

charger_nodes = df_charger["Nearest_Node"].tolist()
# Create a dictionary to hold the charger nodes segregated by charger type
charger_nodes = {}  # Make sure this is a dictionary, not a list

# Loop over each unique charger type and filter the nodes accordingly
for charger_type in df_charger["kW"].unique():
    # Get the list of nearest nodes for the current charger type
    nodes = df_charger[df_charger["kW"] == charger_type]["Nearest_Node"].tolist()
    
    # Assign the list of nodes to the dictionary with the charger type as the key
    charger_nodes[charger_type] = nodes
    # Reversed dictionary to hold the node as the key and the charger type (kW) as the value
charger_nodes_kW = {}

# Loop through the original dictionary
for charger_type, nodes in charger_nodes.items():
    for node in nodes:
        charger_nodes_kW[node] = charger_type
class Car:
    range_L2_cap = {
        "MS": {'range': 2.8, 'cap': 1.75},
        "M3": {'range': 1.3, 'cap': 1},
        "MX": {'range': 2.4, 'cap': 2},
        "MY": {'range': 1.7, 'cap': 1.25}
    }
    
    def __init__(self, model):
        range_calibrate = 1
        self.model = model
        self.range_l2 = Car.range_L2_cap[model]['range'] * range_calibrate
        self.charge_cap = Car.range_L2_cap[model]['cap']
        
    def calculate_penalty(self, charger_kW):
        penalty_l2 = (60 / charger_kW) * self.charge_cap
        return penalty_l2
MS = Car("MS")
M3 = Car("M3")
MX = Car("MX")
MY = Car("MY")

def dijkstra_mod(graph, start, charger_nodes, refill_threshold, car):
    node_attr = {
        node: {
            "penalty_dist": float('infinity'),
            "non_charged_dist": float('infinity'),
            "charged_dist": float('infinity'),
            "previous_node": None
        }
        for node in graph
    }
    threshold = car.range_l2

    # Initialize start node distances
    node_attr[start]["non_charged_dist"] = 0
    node_attr[start]["charged_dist"] = 0
    node_attr[start]["penalty_dist"] = 0

    # Priority queue holds tuples of (penalty distance, non-charged distance, charged distance, node)
    priority_queue = [(0, 0, 0, start)]  # (penalty_dist, non_charged_dist, charged_dist, node)
    
    while priority_queue:
        # Pop the node with the smallest penalty distance
        total_distance, total_dist_wo_penalty, current_distance, current_node = heapq.heappop(priority_queue)

        # Skip processing if the popped node's penalty distance is greater than the already found best distance
        if total_distance > node_attr[current_node]["penalty_dist"]:
            continue

        # Handle charging at charger nodes
        if current_distance >= refill_threshold:
            if current_node in charger_nodes:
                kw = charger_nodes[current_node]
                charging_penalty = car.calculate_penalty(kw) * (current_distance/threshold)
                total_distance = total_distance + charging_penalty
                current_distance = 0  # Reset the charged distance
            
        
        for neighbor in graph.neighbors(current_node):
            weight = graph[current_node][neighbor]['weight']
            charged_distance = current_distance + weight
            non_charged_distance = total_dist_wo_penalty + weight
            penalty_distance = total_distance + weight

            # Skip the neighbor if the charged distance exceeds the threshold
            if charged_distance > threshold:
                continue

            # Update neighbor distances if a better path is found
            if penalty_distance < node_attr[neighbor]["penalty_dist"]:
                node_attr[neighbor]["non_charged_dist"] = non_charged_distance
                node_attr[neighbor]["penalty_dist"] = penalty_distance
                node_attr[neighbor]["charged_dist"] = charged_distance
                node_attr[neighbor]["previous_node"] = current_node
                heapq.heappush(priority_queue, (penalty_distance, non_charged_distance, charged_distance, neighbor))
    
    for node, attr in node_attr.items():
        if attr["charged_dist"] == attr["non_charged_dist"]:
            attr["penalty_dist"] = attr["charged_dist"]
        elif attr["non_charged_dist"] <= threshold:
            attr["penalty_dist"] = attr["non_charged_dist"]

    return node_attr
def reconstruct_path(node_attr, start, target):
    path = []
    current_node = target
    while current_node is not None:
        path.append(current_node)
        current_node = node_attr[current_node]["previous_node"]
    path.reverse()
    return path if path[0] == start else None
sample_nodes = df_nodes['Node'].sample(n=2).reset_index(drop=True)
start_node = sample_nodes[0]
target_node = sample_nodes[1]
print("Start Node: ", start_node)
print("Target Node: ", target_node)
car = M3
refill_threshold_percent = 0.75
refill_threshold = np.floor(car.range_l2 * refill_threshold_percent).astype(int)
node_attr = dijkstra_mod(G, start_node, charger_nodes_kW, refill_threshold, car)
df = pd.DataFrame([
        {
            "Node": node,
            "Post-penalty Dist": attr["penalty_dist"],
            "Distance": attr["non_charged_dist"],
            "Path": None
        }
        for node, attr in node_attr.items()
    ])

df.set_index('Node', inplace=True)
df.sort_index(inplace=True)
df["Path"] = None
for node in G.nodes():
    if node != start_node:
        path = reconstruct_path(node_attr, start_node, node)
        df.at[node, "Path"] = path
df.head()
df["Penalty"] = df["Post-penalty Dist"]-df["Distance"]
print("Target node: ", target_node)
target_node_path = df.loc[target_node]["Path"]
if target_node_path == None:
    print("No path exists from ", start_node," to ", target_node, " for Model: ", car.model)
target_node_path = df.loc[target_node]["Path"]
if target_node_path == None:
    target_node_path_coords = []
else:
    target_node_path_coords = [gdf_nodes.loc[gdf_nodes["Node"] == node].geometry.values[0] for node in target_node_path]
gdf_shortest_path = gpd.GeoDataFrame(geometry=[LineString(target_node_path_coords)])
penalty = df.loc[target_node]["Penalty"]
shortest_path_distance = df.loc[target_node]["Distance"]

if target_node_path != None:
    print("Shortest path distance: ", np.round(shortest_path_distance,4))
    print("Charging Penalty: ", np.round(penalty,4))
else:
    print("No path")

print("Start Node: ", start_node)
print("Target Node: ", target_node)
print("Car Model: ",car.model)
if shortest_path_distance < float('inf'):
    print("Shortest path distance: ", np.round(shortest_path_distance,4))
    print("Charging Penalty: ", np.round(penalty,4))
else:
    print("No path available")

gdf_nodes = gpd.GeoDataFrame(
    df_nodes,
    geometry=gpd.points_from_xy(df_nodes['Longitude'], df_nodes['Latitude'])
)

edge_list = []
for _, edge in df_edges.iterrows():
    node1_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node1']].geometry.values[0]
    node2_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node2']].geometry.values[0]
    edge_list.append(LineString([node1_coords, node2_coords]))

gdf_edges = gpd.GeoDataFrame(geometry=edge_list)

fig, ax = plt.subplots(figsize=(10,10))
gdf_edges.plot(ax=ax,
               linewidth=0.5,
               color='gray')

gdf_nodes.plot(ax=ax,
               color='blue',
               marker='o',
               label='Nodes',
               markersize=0.1)

gdf_shortest_path.plot(ax=ax, linewidth=3, color='red', label='Shortest Path')

charger_points.plot(ax=ax,
                    color='red',
                    marker='^',
                    label='Charger',
                    markersize=3)


gdf_nodes[gdf_nodes['Node'] == start_node].plot(ax=ax, color='orange', marker='s', label='Origin', markersize=30)
gdf_nodes[gdf_nodes['Node'] == target_node].plot(ax=ax, color='black', marker='s', label='Destination', markersize=30)

ax.grid(True)
ax.legend()
ax.set_title("Nodes and Charger Network")

# Adding text box in the top right corner with the required details
info_text = (f"Start Node: {start_node}\n"
             f"Target Node: {target_node}\n"
             f"Car Model: {car.model}\n")

if shortest_path_distance < float('inf'):
    info_text += (f"Shortest Path Distance: {np.round(shortest_path_distance, 4)}\n"
                  f"Charging Penalty: {np.round(penalty, 4)}")
else:
    info_text += "No Path Available"

# Use ax.text to place the information in the top right corner
ax.text(1.05, 1, info_text, transform=ax.transAxes,
        fontsize=10, verticalalignment='top', bbox=dict(facecolor='white', alpha=0.5))

# Adjust the plot to make space for the text box
plt.subplots_adjust(right=0.95)

plt.show()

# Create GeoDataFrame for nodes
gdf_nodes = gpd.GeoDataFrame(
    df_nodes,
    geometry=gpd.points_from_xy(df_nodes['Longitude'], df_nodes['Latitude'])
)

# Create edges
edge_list = []
for _, edge in df_edges.iterrows():
    node1_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node1']].geometry.values[0]
    node2_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node2']].geometry.values[0]
    edge_list.append(LineString([node1_coords, node2_coords]))

gdf_edges = gpd.GeoDataFrame(geometry=edge_list)

# Get origin location coordinates
origin = gdf_nodes.loc[gdf_nodes['Node'] == start_node].iloc[0]

# Create Folium map
map_center = [origin.geometry.y, origin.geometry.x]  # Center map closer to origin
m = folium.Map(location=map_center, zoom_start=10)  # Zoom in more

# Add edges
folium.GeoJson(
    gdf_edges.__geo_interface__,
    style_function=lambda x: {'color': 'gray', 'weight': 1}
).add_to(m)

# Add nodes
for _, node in gdf_nodes.iterrows():
    folium.CircleMarker(
        [node.geometry.y, node.geometry.x],
        radius=0.01,
        color='blue',
        fill=True,
        fillColor='blue',
        fillOpacity=0.2
    ).add_to(m)

# Add shortest path
folium.GeoJson(
    gdf_shortest_path.__geo_interface__,
    style_function=lambda x: {'color': 'red', 'weight': 10}
).add_to(m)

# Add charger points with color based on kW
for _, charger in df_charger.iterrows():
    coordinates = charger['GPS'].split(', ')
    lat, lon = float(coordinates[0]), float(coordinates[1])
    kw = charger['kW']
    zip_code = charger['Zip']
    stalls = charger['Stalls']
    
    if kw == 250:
        marker_color = 'red'
    elif kw == 150:
        marker_color = 'blue'
    elif kw in [120, 122, 125, 120]:
        marker_color = 'gray'
    elif kw == 72:
        marker_color = 'beige'
    else:
        marker_color = 'green'
    
    folium.Marker(
        [lat, lon],
        popup=f"Zip: {zip_code},\nStalls: {stalls},\n{np.floor(kw).astype(int)} kW\n({lat}, {lon})",
        icon=folium.Icon(color=marker_color, icon='bolt', prefix='fa')
    ).add_to(m)


# Add origin and destination
folium.Marker(
    [origin.geometry.y, origin.geometry.x],
    icon=folium.Icon(color='orange', icon='play', prefix='fa'),
    popup='Origin'
).add_to(m)

destination = gdf_nodes.loc[gdf_nodes['Node'] == target_node].iloc[0]

folium.Marker(
    [destination.geometry.y, destination.geometry.x],
    icon=folium.Icon(color='black', icon='flag-checkered', prefix='fa'),
    popup='Destination'
).add_to(m)

# Prepare the text content for the box
info_box_html = f'''
<div style="
    position: fixed;
    top: 10px; right: 10px; 
    width: 250px;
    height: auto;
    padding: 10px;
    background-color: white;
    border: 2px solid gray;
    z-index: 1000;
    font-size: 14px;
    font-family: Arial, sans-serif;
">
    <b>Start Node:</b> {start_node}<br>
    <b>Target Node:</b> {target_node}<br>
    <b>Car Model:</b> {car.model}<br>
'''

if shortest_path_distance < float('inf'):
    info_box_html += f'''
    <b>Path Distance:</b> {np.round(shortest_path_distance, 4)}<br>
    <b>Charging Penalty:</b> {np.round(penalty, 4)}
    '''
else:
    info_box_html += f'''
    <b style="color: red;">No path available</b>
    '''

info_box_html += '</div>'

# Add the information box to the map
m.get_root().html.add_child(folium.Element(info_box_html))


# Add layer control and title
folium.LayerControl().add_to(m)
title_html = '''
             <h3 align="center" style="font-size:16px"><b>Shortest path for charge-constrained EV</b></h3>
             '''
m.get_root().html.add_child(folium.Element(title_html))

# Display the map
m
# Interactive widgets
start_node_dropdown = widgets.Dropdown(
    options=df_nodes['Node'].tolist(),
    description='Start Node:'
)
target_node_dropdown = widgets.Dropdown(
    options=sorted(df_nodes['Node'].tolist(), reverse=True),
    description='Target Node:'
)
car_model_radio = widgets.RadioButtons(
    options=['MS', 'M3', 'MX', 'MY'],
    description='Car Model:'
)
update_button = widgets.Button(description="Update Map")

def update_maps(b):
    start_node = start_node_dropdown.value
    target_node = target_node_dropdown.value
    car_model = car_model_radio.value
    car = Car(car_model)
    refill_threshold_percent = 0.75
    refill_threshold = np.floor(car.range_l2 * refill_threshold_percent).astype(int)
    
    # Run Dijkstra's algorithm
    node_attr = dijkstra_mod(G, start_node, charger_nodes_kW, refill_threshold, car)
    path = reconstruct_path(node_attr, start_node, target_node)
    shortest_path_distance = np.round(node_attr[target_node]["non_charged_dist"],4)
    penalty = np.round(node_attr[target_node]["penalty_dist"] - node_attr[target_node]["non_charged_dist"],4)
    
    print("Start Node: ", start_node)
    print("Target Node: ", target_node)
    print("Car Model: ", car_model)
    if shortest_path_distance < float('inf'):
        print("Shortest path distance: ", np.round(shortest_path_distance,4))
        print("Charging Penalty: ", penalty)
    else:
        print("No path available")

    # Clear output and update the map only
    clear_output(wait=True)
    
    # Geopandas plot
    fig, ax = plt.subplots(figsize=(10, 10))
    gdf_edges.plot(ax=ax, linewidth=0.5, color='gray')
    gdf_nodes.plot(ax=ax, color='blue', marker='o', label='Nodes', markersize=0.1)
    charger_points.plot(ax=ax, color='red', marker='^', label='Charger', markersize=3)
    
    # Plot the shortest path
    path_coords = [G.nodes[node]['pos'] for node in path]
    path_line = LineString(path_coords)
    gpd.GeoSeries([path_line]).plot(ax=ax, color='green', linewidth=2, label='Shortest Path')
    gdf_nodes[gdf_nodes['Node'] == start_node].plot(ax=ax, color='orange', marker='s', label='Origin', markersize=30)
    gdf_nodes[gdf_nodes['Node'] == target_node].plot(ax=ax, color='black', marker='s', label='Destination', markersize=30)

    ax.grid(True)
    ax.legend()
    ax.set_title(f"Shortest Path of Distance: {shortest_path_distance} from Node {start_node} to Node {target_node} for model {car_model} with Charging penalty :{penalty}")
    plt.show()
    
    # Folium map
    origin = gdf_nodes.loc[gdf_nodes['Node'] == start_node].iloc[0]
    map_center = [origin.geometry.y, origin.geometry.x]
    m = folium.Map(location=map_center, zoom_start=10)

    folium.GeoJson(
        gdf_edges.__geo_interface__,
        style_function=lambda x: {'color': 'gray', 'weight': 1}
    ).add_to(m)

    for _, node in gdf_nodes.iterrows():
        folium.CircleMarker(
            [node.geometry.y, node.geometry.x],
            radius=0.01,
            color='blue',
            fill=True,
            fillColor='blue',
            fillOpacity=0.2
        ).add_to(m)
    
    # Add the path to the Folium map
    folium.GeoJson(
        gdf_shortest_path.__geo_interface__,
        style_function=lambda x: {'color': 'red', 'weight': 10, 'opacity': 0.5}  # Adjusting opacity to 50%
    ).add_to(m)
    path_coords = [(G.nodes[node]['pos'][1], G.nodes[node]['pos'][0]) for node in path]
    folium.PolyLine(
        locations=path_coords,
        color='red',
        weight=10,
        opacity=0.5  # Adjusting opacity to 50%
    ).add_to(m)

    for _, charger in df_charger.iterrows():
        coordinates = charger['GPS'].split(', ')
        lat, lon = float(coordinates[0]), float(coordinates[1])
        kw = charger['kW']
        zip_code = charger['Zip']
        stalls = charger['Stalls']
        
        if kw == 250:
            marker_color = 'red'
        elif kw == 150:
            marker_color = 'blue'
        elif kw in [120, 122, 125, 120]:
            marker_color = 'gray'
        elif kw == 72:
            marker_color = 'beige'
        else:
            marker_color = 'green'
        
        folium.Marker(
            [lat, lon],
            popup=f"Zip: {zip_code},\nStalls: {stalls},\n{np.floor(kw).astype(int)} kW\n({lat}, {lon})",
            icon=folium.Icon(color=marker_color, icon='bolt', prefix='fa')
        ).add_to(m)

    folium.Marker(
        [origin.geometry.y, origin.geometry.x],
        icon=folium.Icon(color='orange', icon='play', prefix='fa'),
        popup='Origin'
    ).add_to(m)

    destination = gdf_nodes.loc[gdf_nodes['Node'] == target_node].iloc[0]

    folium.Marker(
        [destination.geometry.y, destination.geometry.x],
        icon=folium.Icon(color='black', icon='flag-checkered', prefix='fa'),
        popup='Destination'
    ).add_to(m)
    
    folium.LayerControl().add_to(m)

    # Display the updated map
    display(m)
    
    # Re-display widgets
    display(start_node_dropdown, target_node_dropdown, car_model_radio, update_button)

# Attach the update function to the button
update_button.on_click(update_maps)

# Display the widgets
display(start_node_dropdown, target_node_dropdown, car_model_radio, update_button)