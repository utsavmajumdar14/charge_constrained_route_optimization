import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd
import heapq
import ipywidgets as widgets
from IPython.display import display, clear_output
filename = 'toy_network2.txt'
def read_graph_from_file(filename):
    graph_df = pd.read_csv(filename, sep=" ", header=None, names=['Source', 'Target', 'Weight'])
    return graph_df
def build_graph_from_df(graph_df):
    G = nx.Graph()
    for _, row in graph_df.iterrows():
        G.add_edge(row['Source'], row['Target'], weight=row['Weight'])
    return G
graph_df = read_graph_from_file(filename)
G = build_graph_from_df(graph_df)
charger_nodes = [2,4,9,17]
quick_charger_nodes = [7,13]
pos_seed = 112
current_figure = None
figure = plt.figure(figsize=(8,6),
                    dpi = 500)
node_colors = []
font_colors = []
for node in G.nodes():
    if node in charger_nodes:
        node_colors.append('purple')
        font_colors.append('white')
    elif node in quick_charger_nodes:
        node_colors.append('blue')
        font_colors.append('white')
    else:
        node_colors.append('cyan')
        font_colors.append('black')

pos = nx.spring_layout(G, seed=pos_seed)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw(G,
        pos,
        with_labels = False,
        # font_weight = 'bold',
        node_size = 50,
        node_color = node_colors,
        # font_size = 3,
        # font_color = font_colors,
        width = 0.5)

for node, font_color in zip(G.nodes(), font_colors):
    nx.draw_networkx_labels(G,
                            pos, 
                            labels={node: node}, 
                            font_color=font_color, 
                            font_size=3, 
                            font_weight='bold')

nx.draw_networkx_edge_labels(G,
                             pos,
                             edge_labels=edge_labels,
                             font_color='red',
                             font_size=2)

plt.show()
def dijkstra_mod(graph, start, charger_nodes, quick_charger_nodes, threshold, charging_penalty, quick_charging_penalty, refill_threshold):
    node_attr = {
        node: {
            "penalty_dist": float('infinity'),
            "non_charged_dist": float('infinity'),
            "charged_dist": float('infinity'),
            "previous_node": None
        }
        for node in graph
    }

    # Initialize start node distances
    node_attr[start]["non_charged_dist"] = 0
    node_attr[start]["charged_dist"] = 0
    node_attr[start]["penalty_dist"] = 0

    # Priority queue holds tuples of (penalty distance, non-charged distance, charged distance, node)
    priority_queue = [(0, 0, 0, start)]  # (penalty_dist, non_charged_dist, charged_dist, node)
    
    while priority_queue:
        # Pop the node with the smallest penalty distance
        total_distance, total_dist_wo_penalty, current_distance, current_node = heapq.heappop(priority_queue)

        # Skip processing if the popped node's penalty distance is greater than the already found best distance
        if total_distance > node_attr[current_node]["penalty_dist"]:
            continue

        # Handle charging at charger nodes
        if current_distance >= refill_threshold:
            if current_node in charger_nodes:
                total_distance = total_distance + charging_penalty
                current_distance = 0  # Reset the charged distance
            
            if current_node in quick_charger_nodes:
                total_distance = total_distance + quick_charging_penalty
                current_distance = 0  # Reset the charged distance
        
        for neighbor in graph.neighbors(current_node):
            weight = graph[current_node][neighbor]['weight']
            charged_distance = current_distance + weight
            non_charged_distance = total_dist_wo_penalty + weight
            penalty_distance = total_distance + weight

            # Skip the neighbor if the charged distance exceeds the threshold
            if charged_distance > threshold:
                continue

            # Update neighbor distances if a better path is found
            if penalty_distance < node_attr[neighbor]["penalty_dist"]:
                node_attr[neighbor]["non_charged_dist"] = non_charged_distance
                node_attr[neighbor]["penalty_dist"] = penalty_distance
                node_attr[neighbor]["charged_dist"] = charged_distance
                node_attr[neighbor]["previous_node"] = current_node
                heapq.heappush(priority_queue, (penalty_distance, non_charged_distance, charged_distance, neighbor))
    
    return node_attr
def reconstruct_path(node_attr, start, target):
    path = []
    current_node = target
    while current_node is not None:
        path.append(current_node)
        current_node = node_attr[current_node]["previous_node"]
    path.reverse()
    return path if path[0] == start else None
def visualize_graph(graph_df, node_attr, charger_nodes, quick_charger_nodes, start_node, target_node, threshold, path_edges):
    G = nx.Graph()
    # figure = plt.figure(figsize=(8, 6), dpi=500)
    
    global current_figure
    if current_figure is not None:
        plt.close(current_figure)  # Close the previous figure

    current_figure = plt.figure(figsize=(8, 6), dpi=500)  # Create a new figure

    plt.clf()
    # Add edges to the graph
    for _, row in graph_df.iterrows():
        G.add_edge(row['Source'], row['Target'], weight=row['Weight'])

    # Initialize node colors, sizes, and font color groups
    node_colors = []
    node_sizes = []
    black_font_nodes = []
    white_font_nodes = []
    
    for node in G.nodes():
        if node == start_node:
            node_colors.append('green')
            node_sizes.append(100)
            black_font_nodes.append(node)
        elif node == target_node:
            node_colors.append('yellow')
            node_sizes.append(100)
            black_font_nodes.append(node)
        elif node in charger_nodes:
            node_colors.append('purple')
            node_sizes.append(180)
            white_font_nodes.append(node)
        elif node in quick_charger_nodes:
            node_colors.append('blue')
            node_sizes.append(200)
            white_font_nodes.append(node)
        else:
            node_colors.append('cyan')
            node_sizes.append(50)
            black_font_nodes.append(node)

    # Define edge labels
    edge_labels = {(row['Source'], row['Target']): row['Weight'] for _, row in graph_df.iterrows()}

    # Define node labels
    node_labels = {node: f"{node}\n({node_attr[node]['non_charged_dist']})" for node in G.nodes()}
    
    # Set edge colors and widths based on path_edges
    edge_colors = ['red' if (edge in path_edges) or (edge[::-1] in path_edges) else 'gray' for edge in G.edges()]
    edge_widths = [2 if (edge in path_edges) or (edge[::-1] in path_edges) else 0.5 for edge in G.edges()]

    # Get positions for the nodes
    pos = nx.spring_layout(G, seed=pos_seed)

    # Draw the graph with custom node sizes
    nx.draw(G, 
            pos, 
            with_labels=False, 
            node_color=node_colors, 
            node_size=node_sizes, 
            edge_color=edge_colors, 
            width=edge_widths)

    # Draw node labels with black font color
    nx.draw_networkx_labels(G, pos, labels={node: node_labels[node] for node in black_font_nodes},
                            font_color='black', font_size=3, font_weight='bold')

    # Draw node labels with white font color
    nx.draw_networkx_labels(G, pos, labels={node: node_labels[node] for node in white_font_nodes},
                            font_color='white', font_size=3, font_weight='bold')

    # Split the edge labels into two sets: one for path edges and another for non-path edges
    path_edge_labels = {}
    for edge in path_edges:
        # Check if the edge or its reverse exists in edge_labels and add it to path_edge_labels
        label = edge_labels.get(edge) or edge_labels.get(edge[::-1])
        if label is not None:
            path_edge_labels[edge] = label

    non_path_edge_labels = {}
    for edge in G.edges():
        if edge not in path_edge_labels and edge[::-1] not in path_edge_labels:
            non_path_edge_labels[edge] = edge_labels.get(edge) or edge_labels.get(edge[::-1])

    # Draw edge labels for path edges with specified font size and color
    nx.draw_networkx_edge_labels(G, pos, edge_labels=path_edge_labels, font_color='darkblue', font_size=4, font_weight='bold')

    # Draw edge labels for non-path edges with default font size and color
    nx.draw_networkx_edge_labels(G, pos, edge_labels=non_path_edge_labels, font_color='red', font_size=3)

    # Set the title and display the plot
    plt.title(f"Shortest Path to Node {target_node} Highlighted and Threshold {threshold}")
    
    shortest_dist = node_attr[target_node]["non_charged_dist"]
    penalty_dist = node_attr[target_node]["penalty_dist"]
    
    plt.text(0.95, 0.95, 
             f"Shortest distance covered: {shortest_dist}\n"
             f"Distance that could've been covered instead of charging: {penalty_dist}",
             transform=plt.gca().transAxes, 
             fontsize=8, 
             verticalalignment='top',
             horizontalalignment='right',
             bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5))
    
    # Add legend
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', label='Normal', markerfacecolor='cyan', markersize=10),
        plt.Line2D([0], [0], marker='o', color='w', label='Start', markerfacecolor='green', markersize=10),
        plt.Line2D([0], [0], marker='o', color='w', label='Target', markerfacecolor='yellow', markersize=10),
        plt.Line2D([0], [0], marker='o', color='w', label='Charger', markerfacecolor='purple', markersize=10),
        plt.Line2D([0], [0], marker='o', color='w', label='Quick charger', markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], color='red', lw=2, label='Shortest path')
    ]
    legend = plt.legend(handles=legend_elements, loc='upper right', fontsize=8, bbox_to_anchor=(0.95, 0.85))
    legend.get_frame().set_alpha(0.5)

    plt.show()

start_node = 0
threshold = 120
charging_penalty = 80
quick_charging_penalty = 30
refill_threshold_percent = 0.5
refill_threshold = np.floor(threshold * refill_threshold_percent).astype(int)
charger_nodes = [2,4,9,17]
quick_charger_nodes = [7,13]

node_attr = dijkstra_mod(G, start_node, charger_nodes, quick_charger_nodes, threshold, charging_penalty, quick_charging_penalty, refill_threshold)
df = pd.DataFrame([
        {
            "Node": node,
            "Post-penalty Dist": attr["penalty_dist"],
            "Distance": attr["non_charged_dist"],
            "Path": None
        }
        for node, attr in node_attr.items()
    ])

df.set_index('Node', inplace=True)
df.sort_index(inplace=True)
df["Path"] = None
for node in G.nodes():
    if node != start_node:
        path = reconstruct_path(node_attr, start_node, node)
        df.at[node, "Path"] = path
df
target_node = 11
path = reconstruct_path(node_attr, start_node, target_node)
print(path)
if path:
    # Highlight the shortest path on the graph
    path_edges = list(zip(path, path[1:]))  # Create pairs of nodes for edges
    visualize_graph(graph_df, node_attr, charger_nodes, quick_charger_nodes, start_node, target_node, threshold, path_edges)
def interactive_visualization(graph_df, node_attr, charger_nodes, quick_charger_nodes, start_node, threshold):
    possible_target_nodes = list(graph_df['Target'].unique()) + list(graph_df['Source'].unique())
    possible_target_nodes = sorted(set(possible_target_nodes))

    target_node_dropdown = widgets.Dropdown(
        options=possible_target_nodes,
        description='Target Node:',
        value=1,
        style={'description_width': 'initial'}
    )
    
    output = widgets.Output()

    def update_visualization(change):
        target_node = change['new']
        path = reconstruct_path(node_attr, start_node, target_node)
        
        with output:
            clear_output(wait=True)
            print(f"Path to {target_node}: {path}")
            
            if path:
                path_edges = list(zip(path, path[1:]))
                visualize_graph(graph_df, node_attr, charger_nodes, quick_charger_nodes, start_node, target_node, threshold, path_edges)
    
    target_node_dropdown.observe(update_visualization, names='value')
    
    display(target_node_dropdown, output)
    
    # Initial visualization
    update_visualization({'new': target_node_dropdown.value})
interactive_visualization(graph_df, node_attr, charger_nodes, quick_charger_nodes, start_node, threshold)


Below is my code so far which is correct.
Now I want to visualize the shortest path on the map.
Write a function that visualizes it


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import folium
import geopandas as gpd
from shapely.geometry import Point
import networkx as nx
from geopy.distance import geodesic
from tqdm import tqdm
from shapely.geometry import LineString
import heapq
import ipywidgets as widgets
from IPython.display import display, clear_output
from IPython.core.display import HTML

datapath = "../new_data/"
df = pd.read_csv(datapath+"Supercharge Locations.csv")
df_CA = df[df["State"]=="CA"]
df_CA = df_CA.drop(columns=["Unnamed: 11","Country","Open Date", "Elev(m)","State"])
df_CA.at[df_CA[df_CA["Zip"].isnull()].index.values[0],"Zip"] = '91007'
df_CA['Latitude'] = None
df_CA['Longitude'] = None

df_CA[['Latitude', 'Longitude']] = df_CA['GPS'].str.split(', ', expand=True)

# Convert Latitude and Longitude to float if needed
df_CA['Latitude'] = df_CA['Latitude'].astype(float)
df_CA['Longitude'] = df_CA['Longitude'].astype(float)

min_lon = -120.4346
max_lon = -118.0784
min_lat = 33.9867
max_lat = 34.9530

df_road_edge = pd.read_csv(datapath+"cal_road_net_edge.csv")
df_road_node = pd.read_csv(datapath+"cal_road_network_node.csv")
# Since the original dataset had Latitude and Longitude reversed we will swap them
df_road_node['Latitude'], df_road_node['Longitude'] = df_road_node['Longitude'], df_road_node['Latitude']

df_road_edge

def limit_coordinates(df, min_lat, max_lat, min_long, max_long):
    # Limit latitude
    df = df[(df['Latitude'] >= min_lat) & (df['Latitude'] <= max_lat)]

    # Limit longitude
    df = df[(df['Longitude'] >= min_long) & (df['Longitude'] <= max_long)]
    return df

df_charger = limit_coordinates(df_CA, min_lat, max_lat, min_lon, max_lon).reset_index()
df_nodes = limit_coordinates(df_road_node, min_lat, max_lat, min_lon, max_lon).reset_index()

df_edges = df_road_edge[df_road_edge["Node1"].isin(df_nodes.Node.to_list()) &
                        df_road_edge["Node2"].isin(df_nodes.Node.to_list())].drop(columns=["Sl"]).reset_index()
df_charger = df_charger.drop(columns="index")
df_nodes = df_nodes.drop(columns="index")
df_edges = df_edges.drop(columns="index")

reduced_map = folium.Map(location=[35, -119], zoom_start=6)
for index, row in df_charger.iterrows():
    zip_code = row['Zip']
    stalls = row['Stalls']
    coordinates = row['GPS'].split(', ')
    kw = row['kW']
    lat, lon = float(coordinates[0]), float(coordinates[1])
    if kw == 250:
        marker_color = 'red'
    elif kw == 150:
        marker_color = 'blue'
    elif kw in [120, 122, 125, 120]:
        marker_color = 'gray'
    elif kw == 72:
        marker_color = 'beige'
    else:
        marker_color = 'green'
    folium.Marker([lat, lon],
                  popup=f"Zip: {zip_code},\nStalls: {stalls},\n{np.floor(kw).astype(int)} kW\n({lat},{lon})",
                  icon=folium.Icon(color=marker_color, icon='bolt', prefix='fa')).add_to(reduced_map)
    
reduced_map

G = nx.Graph()
for index, row in df_nodes.iterrows():
    G.add_node(row['Node'],
               pos=(row['Longitude'], row['Latitude']))
    
for index, row in df_edges.iterrows():
    G.add_edge(row['Node1'], row['Node2'],
               weight = row['Distance'])
    
charger_points = gpd.GeoDataFrame(df_charger,
                                  geometry=gpd.points_from_xy(df_charger['Longitude'], df_charger['Latitude']))

node_to_charger = []

for node in tqdm(G.nodes, desc="Processing nodes"):
    node_coords = df_nodes.loc[df_nodes['Node'] == node,
                               ['Latitude', 'Longitude']].values.flatten()
    
    nearest_charger_distance = float('inf')
    nearest_charger_coords = None

    for idx, charger in charger_points.iterrows():
        charger_coords = (charger['Latitude'], charger['Longitude'])
        distance = geodesic(node_coords, charger_coords).kilometers

        if distance < nearest_charger_distance:
            nearest_charger_distance = distance
            nearest_charger_coords = charger_coords

    node_to_charger.append({
        'Node': node,
        'Nearest_charger': nearest_charger_coords,
        'Distance': nearest_charger_distance
    })

node_to_charger_df = pd.DataFrame(node_to_charger)

charger_to_nearest_node = {}
for idx, charger in charger_points.iterrows():
    charger_coords = (charger['Latitude'], charger['Longitude'])
    nearest_node = None
    min_distance = float('inf')

    for record in node_to_charger:
        if record['Nearest_charger'] == charger_coords:
            if record['Distance'] < min_distance:
                min_distance = record['Distance']
                nearest_node = record['Node']

    if nearest_node is None:
        print(f"No nearest node found for charger at {charger_coords}")
        
    charger_to_nearest_node[tuple(charger_coords)] = nearest_node

charger_to_nearest_node = pd.DataFrame(list(charger_to_nearest_node.items()), columns=['Charger', 'Nearest_Node'])

gdf_nodes = gpd.GeoDataFrame(
    df_nodes,
    geometry=gpd.points_from_xy(df_nodes['Longitude'], df_nodes['Latitude'])
)

edge_list = []
for _, edge in df_edges.iterrows():
    node1_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node1']].geometry.values[0]
    node2_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node2']].geometry.values[0]
    edge_list.append(LineString([node1_coords, node2_coords]))

gdf_edges = gpd.GeoDataFrame(geometry=edge_list)

fig, ax = plt.subplots(figsize=(10,10))
gdf_edges.plot(ax=ax,
               linewidth=1,
               color='gray')

gdf_nodes.plot(ax=ax,
               color='blue',
               marker='o',
               label='Nodes',
               markersize=5)

charger_points.plot(ax=ax,
                    color='red',
                    marker='^',
                    label='Charger',
                    markersize=10)

ax.grid(True)
ax.legend()
ax.set_title("Nodes and Charger Network")

plt.show()

df_charger = pd.concat([charger_points, charger_to_nearest_node], axis=1).drop(columns=["Charger"]).dropna()
df_charger["Nearest_Node"] = np.floor(df_charger["Nearest_Node"]).astype(int)

charger_nodes = df_charger["Nearest_Node"].tolist()

charger_nodes = {} 


for charger_type in df_charger["kW"].unique():
    nodes = df_charger[df_charger["kW"] == charger_type]["Nearest_Node"].tolist()
    charger_nodes[charger_type] = nodes

charger_nodes_kW = {}

# Loop through the original dictionary
for charger_type, nodes in charger_nodes.items():
    for node in nodes:
        charger_nodes_kW[node] = charger_type

class Car:
    range_L2_cap = {
        "MS": {'range': 6.0, 'cap': 1.75},
        "M3": {'range': 2.5, 'cap': 1},
        "MX": {'range': 5.0, 'cap': 2},
        "MY": {'range': 3.6, 'cap': 1.25}
    }
    
    def __init__(self, model):
        self.model = model
        self.range_l2 = Car.range_L2_cap[model]['range']
        self.charge_cap = Car.range_L2_cap[model]['cap']
        
    def calculate_penalty(self, charger_kW):
        penalty_l2 = (60 / charger_kW) * self.charge_cap
        return penalty_l2

MS = Car("MS")
M3 = Car("M3")
MX = Car("MX")
MY = Car("MY")

def dijkstra_mod(graph, start, charger_nodes, refill_threshold, car):
    node_attr = {
        node: {
            "penalty_dist": float('infinity'),
            "non_charged_dist": float('infinity'),
            "charged_dist": float('infinity'),
            "previous_node": None
        }
        for node in graph
    }
    threshold = car.range_l2

    # Initialize start node distances
    node_attr[start]["non_charged_dist"] = 0
    node_attr[start]["charged_dist"] = 0
    node_attr[start]["penalty_dist"] = 0

    # Priority queue holds tuples of (penalty distance, non-charged distance, charged distance, node)
    priority_queue = [(0, 0, 0, start)]  # (penalty_dist, non_charged_dist, charged_dist, node)
    
    while priority_queue:
        # Pop the node with the smallest penalty distance
        total_distance, total_dist_wo_penalty, current_distance, current_node = heapq.heappop(priority_queue)

        # Skip processing if the popped node's penalty distance is greater than the already found best distance
        if total_distance > node_attr[current_node]["penalty_dist"]:
            continue

        # Handle charging at charger nodes
        if current_distance >= refill_threshold:
            if current_node in charger_nodes:
                kw = charger_nodes[current_node]
                charging_penalty = car.calculate_penalty(kw) * (current_distance/threshold)
                total_distance = total_distance + charging_penalty
                current_distance = 0  # Reset the charged distance
            
        
        for neighbor in graph.neighbors(current_node):
            weight = graph[current_node][neighbor]['weight']
            charged_distance = current_distance + weight
            non_charged_distance = total_dist_wo_penalty + weight
            penalty_distance = total_distance + weight

            # Skip the neighbor if the charged distance exceeds the threshold
            if charged_distance > threshold:
                continue

            # Update neighbor distances if a better path is found
            if penalty_distance < node_attr[neighbor]["penalty_dist"]:
                node_attr[neighbor]["non_charged_dist"] = non_charged_distance
                node_attr[neighbor]["penalty_dist"] = penalty_distance
                node_attr[neighbor]["charged_dist"] = charged_distance
                node_attr[neighbor]["previous_node"] = current_node
                heapq.heappush(priority_queue, (penalty_distance, non_charged_distance, charged_distance, neighbor))
    
    for node, attr in node_attr.items():
        if attr["charged_dist"] == attr["non_charged_dist"]:
            attr["penalty_dist"] = attr["charged_dist"]

    return node_attr

def reconstruct_path(node_attr, start, target):
    path = []
    current_node = target
    while current_node is not None:
        path.append(current_node)
        current_node = node_attr[current_node]["previous_node"]
    path.reverse()
    return path if path[0] == start else None

sample_nodes = df_nodes['Node'].sample(n=2).reset_index(drop=True)
start_node = sample_nodes[0]
target_node = sample_nodes[1]
car = MS
refill_threshold_percent = 0.75
refill_threshold = np.floor(car.range_l2 * refill_threshold_percent).astype(int)

node_attr = dijkstra_mod(G, start_node, charger_nodes_kW, refill_threshold, car)

df = pd.DataFrame([
        {
            "Node": node,
            "Post-penalty Dist": attr["penalty_dist"],
            "Distance": attr["non_charged_dist"],
            "Path": None
        }
        for node, attr in node_attr.items()
    ])

df.set_index('Node', inplace=True)
df.sort_index(inplace=True)

df["Path"] = None
for node in G.nodes():
    if node != start_node:
        path = reconstruct_path(node_attr, start_node, node)
        df.at[node, "Path"] = path

df["Penalty"] = df["Post-penalty Dist"]-df["Distance"]

target_node_path = df.loc[target_node]["Path"]
gdf_shortest_path = gpd.GeoDataFrame(geometry=[LineString(target_node_path)])

gdf_nodes = gpd.GeoDataFrame(
    df_nodes,
    geometry=gpd.points_from_xy(df_nodes['Longitude'], df_nodes['Latitude'])
)

edge_list = []
for _, edge in df_edges.iterrows():
    node1_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node1']].geometry.values[0]
    node2_coords = gdf_nodes.loc[gdf_nodes['Node'] == edge['Node2']].geometry.values[0]
    edge_list.append(LineString([node1_coords, node2_coords]))

gdf_edges = gpd.GeoDataFrame(geometry=edge_list)

fig, ax = plt.subplots(figsize=(10,10))
gdf_edges.plot(ax=ax,
               linewidth=1,
               color='gray')

gdf_nodes.plot(ax=ax,
               color='blue',
               marker='o',
               label='Nodes',
               markersize=5)

gdf_shortest_path.plot(ax=ax, linewidth=5, color='red', label='Shortest Path')

charger_points.plot(ax=ax,
                    color='red',
                    marker='^',
                    label='Charger',
                    markersize=10)

ax.grid(True)
ax.legend()
ax.set_title("Nodes and Charger Network")

plt.show()